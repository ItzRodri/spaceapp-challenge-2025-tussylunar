<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky View Test</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; padding: 0; background: black; overflow: hidden; }
        #info { position: absolute; top: 10px; left: 10px; color: white; z-index: 100; }
        #search { position: absolute; top: 10px; left: 10px; z-index: 100; }
    </style>
</head>
<body>
    <div id="search">
        <input type="text" id="planet-search" placeholder="Enter planet name" 
               style="padding: 10px; border: 1px solid #ccc; border-radius: 5px; background: white; color: black; width: 200px;">
    </div>
    
    <div id="info" style="top: 60px;">
        <div id="object-count">Loading...</div>
        <div id="hover-info" style="font-size: 12px;"></div>
    </div>
    
    <canvas id="sky-canvas"></canvas>

    <script>
        // Simple three.js scene
        const canvas = document.getElementById('sky-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = true;
        controls.enablePan = false;
        controls.minDistance = 5;
        controls.maxDistance = 100;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const planetGroup = new THREE.Group();
        scene.add(planetGroup);

        let skyObjects = [];
        let hoveredObject = null;

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        function raDecToCartesian(raDeg, decDeg, distance) {
            const raRad = THREE.MathUtils.degToRad(raDeg);
            const decRad = THREE.MathUtils.degToRad(decDeg);
            const x = distance * Math.cos(decRad) * Math.cos(raRad);
            const y = distance * Math.cos(decRad) * Math.sin(raRad);
            const z = distance * Math.sin(decRad);
            return new THREE.Vector3(x, y, z);
        }

        async function loadSkyObjects() {
            try {
                console.log('Loading sky objects...');
                const res = await fetch('/api/sky/objects');
                if (!res.ok) {
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                const data = await res.json();
                skyObjects = data.objects || [];
                
                console.log(`Loaded ${skyObjects.length} objects`);

                document.getElementById('object-count').innerHTML = `
                    <strong>Objects:</strong> ${skyObjects.length}<br>
                    <small>TESS: ${skyObjects.filter(o => o.mission === 'tess').length} | 
                    Kepler: ${skyObjects.filter(o => o.mission === 'kepler').length}</small>
                `;

                skyObjects.forEach((obj, idx) => {
                    const radius = 0.3 + Math.random() * 0.4;
                    const sphereGeo = new THREE.SphereGeometry(radius, 8, 8);
                    
                    const color = obj.mission === 'tess' ? 0x44ccff : 0xffcc44;
                    const material = new THREE.MeshBasicMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const mesh = new THREE.Mesh(sphereGeo, material);
                    
                    const distance = 15 + (idx % 10) * 2;
                    const pos = raDecToCartesian(obj.ra_deg, obj.dec_deg, distance);
                    mesh.position.copy(pos);
                    
                    mesh.userData = { 
                        id: obj.id, 
                        meta: obj,
                        originalColor: color,
                        originalOpacity: 0.9
                    };
                    
                    planetGroup.add(mesh);
                });

                console.log('Sky objects loaded successfully');
                
            } catch (error) {
                console.error('Failed to load sky objects:', error);
                document.getElementById('object-count').innerHTML = `
                    <div style="color: red;">
                        <strong>Error:</strong> ${error.message}
                    </div>
                `;
            }
        }

        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planetGroup.children, true);
            
            if (hoveredObject) {
                hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                hoveredObject.material.opacity = hoveredObject.userData.originalOpacity;
            }
            
            if (intersects.length) {
                const obj = intersects[0].object;
                obj.material.color.setHex(0xff0000);
                obj.material.opacity = 1.0;
                hoveredObject = obj;
                
                const meta = obj.userData.meta;
                document.getElementById('hover-info').innerHTML = `
                    <strong>${meta.id}</strong><br>
                    Mission: ${meta.mission.toUpperCase()}<br>
                    Period: ${meta.orbital_period_days} days
                `;
            } else {
                hoveredObject = null;
                document.getElementById('hover-info').innerHTML = '';
            }
        });

        canvas.addEventListener('click', async (event) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planetGroup.children, true);
            
            if (intersects.length) {
                const obj = intersects[0].object.userData.meta;
                alert(`Clicked on ${obj.id} - Mission: ${obj.mission.toUpperCase()}`);
            }
        });

        document.getElementById('planet-search').addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            planetGroup.children.forEach(child => {
                if (child.userData && child.userData.meta) {
                    const isVisible = child.userData.meta.id.toLowerCase().includes(searchTerm);
                    child.visible = isVisible;
                }
            });
        });

        loadSkyObjects();
    </script>
</body>
</html>
